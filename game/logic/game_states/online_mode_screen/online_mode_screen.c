#include <cstb.h>

///////////////////////////////////////
// C types for structured data
///////////////////////////////////////

///////////////////////////////////////
// Global labels from the ASM codebase
///////////////////////////////////////

extern uint8_t const menu_online_mode_nametable;
extern uint8_t const menu_online_mode_palette;
extern uint8_t const tileset_menu_online_mode;
extern uint8_t const tileset_menu_online_mode_sprites;

extern uint8_t volatile RAINBOW_WRAM_BANKING;

///////////////////////////////////////
// Screen specific ASM functions
///////////////////////////////////////

void online_mode_screen_tick_music();

///////////////////////////////////////
// Constants specific to this file
///////////////////////////////////////

uint8_t const NB_OPTIONS = 3;
uint8_t const OPTION_CASUAL = 0;
uint8_t const OPTION_RANKED = 1;
uint8_t const OPTION_LOGIN = 2;

typedef enum {
	LOGIN_UNLOGGED = 0,
	LOGIN_ANONYMOUS,
	LOGIN_LOGGED
} LoginState;

//uint8_t const NB_SPRITE_PER_OPTION = 16; // C forbids the use of constants in constant arrays, so make it a macro :(
#define NB_SPRITE_PER_OPTION 16

static uint8_t const earth_sprite_per_option[][NB_SPRITE_PER_OPTION] = {
	{
		255, 255, 0, 1,
		255, 2, 3, 4,
		5, 6, 7, 8,
		9, 10, 11, 12
	},
	{
		13, 14, 255, 255,
		15, 16, 17, 255,
		18, 19, 20, 21,
		22, 23, 24, 25
	},
	{
		26, 27, 28, 29,
		30, 31, 32, 33,
		255, 34, 35, 36,
		255, 255, 37, 38
	},
};

struct Position16 {
    uint16_t x;
    uint16_t y;
};

static struct Position16 const first_earth_sprite_per_option[] = {
	{80, 79},
	{144, 79},
	{80, 143},
};

///////////////////////////////////////
// STNP login extension
//  Login is not described in STNP doc,
//  let define it as an extension here.
///////////////////////////////////////

// High number at the "message_type" position to avoid ambiguity with standard STNP messages
#define STNP_LOGIN_MSG_TYPE 255

// Login method
#define STNP_LOGIN_ANONYMOUS 0
#define STNP_LOGIN_PASSWORD 1

///////////////////////////////////////
// Utility functions
///////////////////////////////////////

/** Not a real yield, pass a frame "as if" it gone through main loop */
static void yield() {
	wait_next_frame();
	online_mode_screen_tick_music();
	reset_nt_buffers();
}

static void anonymous_login() {
	static uint8_t const set_protocol_cmd[] = {
		2, TOESP_MSG_SET_SERVER_PROTOCOL,
		ESP_PROTOCOL_UDP
	};

	static uint8_t const set_server_cmd[] = {
#if 0
		// ESP header
		23, TOESP_MSG_SET_SERVER_SETTINGS,
		// Port
		0x12, 0x34,
		// Address
		's', 't', 'b', '-', 'l', 'o', 'g', 'i', 'n', '.', 'w', 'o', 'n', 't', 'f', 'i', 'x', '.', 'i', 't',
#else
		// ESP header
		12, TOESP_MSG_SET_SERVER_SETTINGS,
		// Port
		0x12, 0x34,
		// Address
		'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't',
#endif
	};

	static uint8_t const login_msg_cmd[] = {
		// ESP header
		3, TOESP_MSG_SEND_MESSAGE_TO_SERVER,
		// STNP message type
		STNP_LOGIN_MSG_TYPE,
		// Anonymous login
		STNP_LOGIN_ANONYMOUS
	};

	static uint8_t const esp_clear_cmd[] = {1, TOESP_MSG_CLEAR_BUFFERS};
	static uint8_t const connect_cmd[] = {1, TOESP_MSG_CONNECT_TO_SERVER};

	// Clear ESP messages queue (avoid the mem_buffer being overflowed by a big remaining message)
	//TODO draw "connecting to server" window
	wrap_esp_send_cmd(esp_clear_cmd);
	yield();

	// Contact login server to get an anonymous ID
	wrap_esp_send_cmd(set_protocol_cmd);
	wrap_esp_send_cmd(set_server_cmd);
	wrap_esp_send_cmd(connect_cmd);
	yield();

	wrap_esp_send_cmd(login_msg_cmd);
	yield();

	while(
		wrap_esp_get_msg(online_mode_selection_mem_buffer) != 8 ||
		online_mode_selection_mem_buffer[1] != FROMESP_MSG_MESSAGE_FROM_SERVER ||
		online_mode_selection_mem_buffer[2] != STNP_LOGIN_MSG_TYPE
	)
	{
		yield();
	}

	network_client_id_byte0[0] = online_mode_selection_mem_buffer[5];
	network_client_id_byte0[1] = online_mode_selection_mem_buffer[6];
	network_client_id_byte0[2] = online_mode_selection_mem_buffer[7];
	network_client_id_byte0[3] = online_mode_selection_mem_buffer[8];

	// Mark logged as anonymous
	*network_logged = LOGIN_ANONYMOUS;

#if 0
	// Local version, using a random ID generated by the ESP

	static uint8_t const rnd_cmd[] = {1, TOESP_MSG_GET_RND_WORD};

	// Request random number's lowest nibbles
	wrap_esp_send_cmd(rnd_cmd);
	yield();

	while(wrap_esp_get_msg(online_mode_selection_mem_buffer) != 3 || online_mode_selection_mem_buffer[1] != FROMESP_MSG_RND_WORD) {
		yield();
	}
	network_client_id_byte0[0] = online_mode_selection_mem_buffer[2];
	network_client_id_byte0[1] = online_mode_selection_mem_buffer[3];

	// Request random number's highest nibbles
	wrap_esp_send_cmd(rnd_cmd);
	yield();

	while(wrap_esp_get_msg(online_mode_selection_mem_buffer) != 3 || online_mode_selection_mem_buffer[1] != FROMESP_MSG_RND_WORD) {
		yield();
	}
	network_client_id_byte0[2] = online_mode_selection_mem_buffer[2];
	network_client_id_byte0[3] = online_mode_selection_mem_buffer[3];

	// Mark logged as anonymous
	*network_logged = LOGIN_ANONYMOUS;
#endif
}

///////////////////////////////////////
// State implementation
///////////////////////////////////////

void audio_play_parry();
static void sound_effect_click() {
	audio_play_parry();
}

static void next_screen() {
	switch (*online_mode_selection_current_option) {
		case OPTION_CASUAL:
			if (*network_logged == LOGIN_UNLOGGED) {
				anonymous_login();
			}
			wrap_change_global_game_state(GAME_STATE_CHARACTER_SELECTION);
			break;
		case OPTION_RANKED:
			//TODO
			break;
		case OPTION_LOGIN:
			//TODO
			break;
	}
}

static void previous_screen() {
	wrap_change_global_game_state(GAME_STATE_MODE_SELECTION);
}

static void take_input(uint8_t controller_btns, uint8_t last_fame_btns) {
	if (controller_btns != last_fame_btns) {
		switch (controller_btns) {
			case CONTROLLER_BTN_DOWN:
				sound_effect_click();
				*online_mode_selection_current_option = (*online_mode_selection_current_option + 2) % NB_OPTIONS;
				break;
			case CONTROLLER_BTN_UP:
				sound_effect_click();
				if (*online_mode_selection_current_option < 2) {
					*online_mode_selection_current_option += NB_OPTIONS;
				}
				*online_mode_selection_current_option -= 2;
				break;
			case CONTROLLER_BTN_LEFT:
				sound_effect_click();
				if (*online_mode_selection_current_option > 0) {
					--*online_mode_selection_current_option;
				}else {
					*online_mode_selection_current_option = NB_OPTIONS - 1;
				}
				break;
			case CONTROLLER_BTN_RIGHT:
				sound_effect_click();
				*online_mode_selection_current_option = (*online_mode_selection_current_option + 1) % NB_OPTIONS;
				break;

			// Buttons that take effect on release
			case 0:
				switch (last_fame_btns) {
					case CONTROLLER_BTN_A:
					case CONTROLLER_BTN_START:
						sound_effect_click();
						next_screen();
						break;
					case CONTROLLER_BTN_B:
						sound_effect_click();
						previous_screen();
						break;
					default:
						break;
				};
				break;
			default:
				break;
		};
	}
}

static void highlight_option() {
	// Place earth sprites behind selected box, and above others
	for (uint8_t option = 0; option < NB_OPTIONS; ++option) {
		uint8_t const attributes = (option == *online_mode_selection_current_option ? 0x20 : 0x00);
		for (uint8_t y = 0; y < 4; ++y) {
			for (uint8_t x = 0; x < 4; ++x) {
				uint8_t const tile_index = earth_sprite_per_option[option][y * 4 + x];
				if (tile_index != 255) {
					uint8_t const sprite_num = option * NB_SPRITE_PER_OPTION + y * 4 + x;
					uint8_t const sprite_offset = sprite_num * 4;
					oam_mirror[sprite_offset + 2] = attributes;
				}
			}
		}
	}

	// Set boxes palette
	static uint8_t const buffers_header[][3+48] = {
		{
			0x23, 0xc8, 48,
			0x5f, 0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00,
			0x55, 0x55, 0x55, 0x11, 0x00, 0x00, 0x00, 0x00,
			0x05, 0x05, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		},
		{
			0x23, 0xc8, 48,
			0x0f, 0x00, 0x00, 0x00, 0x50, 0x50, 0x50, 0x50,
			0x00, 0x00, 0x00, 0x00, 0x44, 0x55, 0x55, 0x55,
			0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x05, 0x05,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		},
		{
			0x23, 0xc8, 48,
			0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x50, 0x50, 0x10, 0x00, 0x00, 0x00, 0x00,
			0x55, 0x55, 0x55, 0x11, 0x00, 0x00, 0x00, 0x00,
			0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00,
		},
	};
	wrap_push_nt_buffer(buffers_header[*online_mode_selection_current_option]);
}

void init_online_mode_screen_extra() {
	// Draw static part of the screen
	wrap_construct_palettes_nt_buffer(&menu_online_mode_palette);
	wrap_draw_zipped_nametable(&menu_online_mode_nametable);
	wrap_cpu_to_ppu_copy_tiles((&tileset_menu_online_mode)+1, 0x1000, tileset_menu_online_mode);
	wrap_cpu_to_ppu_copy_tiles((&tileset_menu_online_mode_sprites)+1, 0x0000, tileset_menu_online_mode_sprites);

	// Place earth sprites
	for (uint8_t option = 0; option < NB_OPTIONS; ++option) {
		struct Position16 const sprites_postion = first_earth_sprite_per_option[option];
		for (uint8_t y = 0; y < 4; ++y) {
			uint8_t const pixel_y = sprites_postion.y + 8 * y;
			for (uint8_t x = 0; x < 4; ++x) {
				uint8_t const tile_index = earth_sprite_per_option[option][y * 4 + x];
				if (tile_index != 255) {
					uint8_t const pixel_x = sprites_postion.x + 8 * x;
					uint8_t const sprite_num = option * NB_SPRITE_PER_OPTION + y * 4 + x;
					uint8_t const sprite_offset = sprite_num * 4;
					oam_mirror[sprite_offset + 0] = pixel_y;
					oam_mirror[sprite_offset + 1] = tile_index;
					oam_mirror[sprite_offset + 2] = 0;
					oam_mirror[sprite_offset + 3] = pixel_x;
				}
			}
		}
	}

	// Force RAINBOW WRAM in $6000-$7fff range
	RAINBOW_WRAM_BANKING = 0x80;

	// Initialize state
	*online_mode_selection_current_option = 0;

	// Initialize State in WRAM (TODO do it only once, to stay logged even after quitting the menu)
	*network_logged = 0;
	for (uint8_t i = 0; i < 16; ++i) {
		network_login[i] = 0;
		network_passord[i] = 0;
	}
	for (uint8_t i = 0; i < 4; ++i) {
		network_client_id_byte0[i] = 0;
	}
}

void online_mode_screen_tick_extra() {
	reset_nt_buffers();

	for (uint8_t player = 0; player < 2; ++player) {
		take_input(controller_a_btns[player], controller_a_last_frame_btns[player]);
	}

	highlight_option();
}
